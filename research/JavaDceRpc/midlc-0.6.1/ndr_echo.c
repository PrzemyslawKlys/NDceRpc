/* Generated by MIDLC Wed Feb  9 23:42:37 2005
 */
#include "includes.h"
#include "librpc/gen_ndr/ndr_echo.h"
#include "src/ndr.c"

static void *
midlc_talloc_alloc(void *context, size_t size, int flags)
{
    (void)flags;
    return talloc_size(context, size);
}
static void *
midlc_talloc_realloc(void *context, void *ptr, size_t size)
{
    return talloc_realloc_size(context, ptr, size);
}
static int
midlc_talloc_free(void *context, void *obj)
{
    (void)context;
    return talloc_free(obj);
}

/* pidl doesn't emit typedef'd decls */
typedef struct echo_info1 echo_info1;
typedef struct echo_info2 echo_info2;
typedef struct echo_info3 echo_info3;
typedef struct echo_info4 echo_info4;
typedef struct echo_info5 echo_info5;
typedef struct echo_info6 echo_info6;
typedef union echo_XXX echo_XXX;
typedef struct echo_info7 echo_info7;
typedef union echo_Info echo_Info;
typedef enum echo_Enum1 echo_Enum1;
typedef enum echo_Enum1_32 echo_Enum1_32;
typedef struct echo_Enum2 echo_Enum2;
typedef union echo_Enum3 echo_Enum3;

struct params_echo_AddOne {
    uint32 *v;
};

struct params_echo_EchoData {
    uint32 len;
    uint8 *in_data;
    uint8 *out_data;
};

struct params_echo_SinkData {
    uint32 len;
    uint8 *data;
};

struct params_echo_SourceData {
    uint32 len;
    uint8 *data;
};

struct params_echo_TestCall {
    char_t *s1;
    char_t *s2;
};

struct params_echo_TestCall2 {
    NTSTATUS retval;
    uint16 level;
    echo_Info *info;
};

struct params_echo_TestSleep {
    uint32 retval;
    uint32 seconds;
};

struct params_echo_TestEnum {
    echo_Enum1 *foo1;
    echo_Enum2 *foo2;
    echo_Enum3 *foo3;
};

int
dec_NTSTATUS(struct ndr *ndr, NTSTATUS *obj, size_t *off)
{

    dec_ndr_align(ndr, 4, off);

    dec_ndr_long(ndr, &obj->v, off);


    return 0;
}
int
enc_NTSTATUS(struct ndr *ndr, NTSTATUS *obj, size_t *off)
{

    enc_ndr_align(ndr, 4, off);
    enc_ndr_long(ndr, obj->v, off);


    return 0;
}
static int
enc_in_params_echo_AddOne(struct ndr *ndr, struct params_echo_AddOne *obj, size_t *off)
{

    enc_ndr_long(ndr, *obj->v, off);


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
dec_in_params_echo_AddOne(struct ndr *ndr, struct params_echo_AddOne *obj, size_t *off)
{

    if (obj->v == NULL)
        obj->v = ndr->alloc(ndr->alloc_context, sizeof(uint32_t), ndr->alloc_flags);
    dec_ndr_long(ndr, obj->v, off);


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
enc_out_params_echo_AddOne(struct ndr *ndr, struct params_echo_AddOne *obj, size_t *off)
{

    enc_ndr_long(ndr, *obj->v, off);


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
dec_out_params_echo_AddOne(struct ndr *ndr, struct params_echo_AddOne *obj, size_t *off)
{

    if (obj->v == NULL)
        obj->v = ndr->alloc(ndr->alloc_context, sizeof(uint32_t), ndr->alloc_flags);
    dec_ndr_long(ndr, obj->v, off);


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static NTSTATUS
ndr_pull_echo_AddOne(struct ndr_pull *_ndr, int flags, struct echo_AddOne *r)
{
	struct ndr ndr;
	struct params_echo_AddOne params;

	memset(&params, 0, sizeof(params));
	ndr_init(&ndr,
			_ndr->data,
			_ndr->data_size,
			midlc_talloc_alloc,
			midlc_talloc_realloc,
			midlc_talloc_free,
			_ndr);

	if ((flags & NDR_OUT)) {
		dec_out_params_echo_AddOne(&ndr, &params, &ndr.deferred);
	}
	if ((flags & NDR_IN)) {
		dec_in_params_echo_AddOne(&ndr, &params, &ndr.deferred);
	}
    r->in.v = params.v;
    r->out.v = params.v;

	return NT_STATUS_OK;
}
static NTSTATUS
ndr_push_echo_AddOne(struct ndr_push *_ndr, int flags, struct echo_AddOne *r)
{
	struct ndr ndr;
	struct params_echo_AddOne params;

	memset(&params, 0, sizeof(params));
	ndr_init(&ndr,
			_ndr->data,
			_ndr->alloc_size,
			midlc_talloc_alloc,
			midlc_talloc_realloc,
			midlc_talloc_free,
			_ndr);

    params.v = r->in.v;
    params.v = r->out.v;

	if ((flags & NDR_OUT)) {
		enc_out_params_echo_AddOne(&ndr, &params, &ndr.deferred);
	}
	if ((flags & NDR_IN)) {
		enc_in_params_echo_AddOne(&ndr, &params, &ndr.deferred);
	}
	_ndr->data = ndr.data;
	_ndr->alloc_size = ndr.data_size;
	_ndr->offset = ndr.deferred;

	return NT_STATUS_OK;
}
void ndr_print_echo_AddOne(struct ndr_print *ndr, const char *name, int flags, struct echo_AddOne *r) { (void)ndr; (void)name; (void)flags; (void)r; };

static int
enc_in_params_echo_EchoData(struct ndr *ndr, struct params_echo_EchoData *obj, size_t *off)
{
    uint32_t _in_datas;
    size_t _in_datao;
    uint32_t _i;

    enc_ndr_long(ndr, obj->len, off);

    _in_datas = obj->len;
    enc_ndr_long(ndr, _in_datas, off);
    _in_datao = *off;
    *off += 1 * _in_datas;
    off = &_in_datao;
    for (_i = 0; _i < _in_datas; _i++) {
        enc_ndr_small(ndr, obj->in_data[_i], off);
    }



    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
dec_in_params_echo_EchoData(struct ndr *ndr, struct params_echo_EchoData *obj, size_t *off)
{
    uint32_t _in_datas;
    size_t _in_datao;
    uint32_t _i;
    uint32_t _out_datas;

    dec_ndr_long(ndr, &obj->len, off);

    _in_datas = obj->len;
    dec_ndr_long(ndr, &_in_datas, off);
    _in_datao = *off;
    *off += 1 * _in_datas;
    if (_in_datas > 0xFFFF) return -1;
    if (obj->in_data == NULL)
        obj->in_data = ndr->alloc(ndr->alloc_context, _in_datas * sizeof(uint8_t), ndr->alloc_flags);
    off = &_in_datao;
    for (_i = 0; _i < _in_datas; _i++) {
        dec_ndr_small(ndr, obj->in_data + _i, off);
    }

    _out_datas = obj->len;
    if (_out_datas > 0xFFFF) return -1;
    if (obj->out_data == NULL)
        obj->out_data = ndr->alloc(ndr->alloc_context, _out_datas * sizeof(uint8_t), ndr->alloc_flags);


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
enc_out_params_echo_EchoData(struct ndr *ndr, struct params_echo_EchoData *obj, size_t *off)
{
    uint32_t _out_datas;
    size_t _out_datao;
    uint32_t _i;

    _out_datas = obj->len;
    _out_datao = *off;
    *off += 1 * _out_datas;
    off = &_out_datao;
    for (_i = 0; _i < _out_datas; _i++) {
        enc_ndr_small(ndr, obj->out_data[_i], off);
    }



    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
dec_out_params_echo_EchoData(struct ndr *ndr, struct params_echo_EchoData *obj, size_t *off)
{
    uint32_t _in_datas;
    uint32_t _out_datas;
    size_t _out_datao;
    uint32_t _i;


    _in_datas = obj->len;
    if (_in_datas > 0xFFFF) return -1;
    if (obj->in_data == NULL)
        obj->in_data = ndr->alloc(ndr->alloc_context, _in_datas * sizeof(uint8_t), ndr->alloc_flags);

    _out_datas = obj->len;
    _out_datao = *off;
    *off += 1 * _out_datas;
    if (_out_datas > 0xFFFF) return -1;
    if (obj->out_data == NULL)
        obj->out_data = ndr->alloc(ndr->alloc_context, _out_datas * sizeof(uint8_t), ndr->alloc_flags);
    off = &_out_datao;
    for (_i = 0; _i < _out_datas; _i++) {
        dec_ndr_small(ndr, &obj->out_data[_i], off);
    }


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static NTSTATUS
ndr_pull_echo_EchoData(struct ndr_pull *_ndr, int flags, struct echo_EchoData *r)
{
	struct ndr ndr;
	struct params_echo_EchoData params;

	memset(&params, 0, sizeof(params));
	ndr_init(&ndr,
			_ndr->data,
			_ndr->data_size,
			midlc_talloc_alloc,
			midlc_talloc_realloc,
			midlc_talloc_free,
			_ndr);

	if ((flags & NDR_OUT)) {
		dec_out_params_echo_EchoData(&ndr, &params, &ndr.deferred);
	}
	if ((flags & NDR_IN)) {
		dec_in_params_echo_EchoData(&ndr, &params, &ndr.deferred);
	}
    r->in.len = params.len;
    r->in.in_data = params.in_data;
    r->out.out_data = params.out_data;

	return NT_STATUS_OK;
}
static NTSTATUS
ndr_push_echo_EchoData(struct ndr_push *_ndr, int flags, struct echo_EchoData *r)
{
	struct ndr ndr;
	struct params_echo_EchoData params;

	memset(&params, 0, sizeof(params));
	ndr_init(&ndr,
			_ndr->data,
			_ndr->alloc_size,
			midlc_talloc_alloc,
			midlc_talloc_realloc,
			midlc_talloc_free,
			_ndr);

    params.len = r->in.len;
    params.in_data = r->in.in_data;
    params.out_data = r->out.out_data;

	if ((flags & NDR_OUT)) {
		enc_out_params_echo_EchoData(&ndr, &params, &ndr.deferred);
	}
	if ((flags & NDR_IN)) {
		enc_in_params_echo_EchoData(&ndr, &params, &ndr.deferred);
	}
	_ndr->data = ndr.data;
	_ndr->alloc_size = ndr.data_size;
	_ndr->offset = ndr.deferred;

	return NT_STATUS_OK;
}
void ndr_print_echo_EchoData(struct ndr_print *ndr, const char *name, int flags, struct echo_EchoData *r) { (void)ndr; (void)name; (void)flags; (void)r; };

static int
enc_in_params_echo_SinkData(struct ndr *ndr, struct params_echo_SinkData *obj, size_t *off)
{
    uint32_t _datas;
    size_t _datao;
    uint32_t _i;

    enc_ndr_long(ndr, obj->len, off);

    _datas = obj->len;
    enc_ndr_long(ndr, _datas, off);
    _datao = *off;
    *off += 1 * _datas;
    off = &_datao;
    for (_i = 0; _i < _datas; _i++) {
        enc_ndr_small(ndr, obj->data[_i], off);
    }



    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
dec_in_params_echo_SinkData(struct ndr *ndr, struct params_echo_SinkData *obj, size_t *off)
{
    uint32_t _datas;
    size_t _datao;
    uint32_t _i;

    dec_ndr_long(ndr, &obj->len, off);

    _datas = obj->len;
    dec_ndr_long(ndr, &_datas, off);
    _datao = *off;
    *off += 1 * _datas;
    if (_datas > 0xFFFF) return -1;
    if (obj->data == NULL)
        obj->data = ndr->alloc(ndr->alloc_context, _datas * sizeof(uint8_t), ndr->alloc_flags);
    off = &_datao;
    for (_i = 0; _i < _datas; _i++) {
        dec_ndr_small(ndr, obj->data + _i, off);
    }


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
enc_out_params_echo_SinkData(struct ndr *ndr, struct params_echo_SinkData *obj, size_t *off)
{


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
dec_out_params_echo_SinkData(struct ndr *ndr, struct params_echo_SinkData *obj, size_t *off)
{
    uint32_t _datas;


    _datas = obj->len;
    if (_datas > 0xFFFF) return -1;
    if (obj->data == NULL)
        obj->data = ndr->alloc(ndr->alloc_context, _datas * sizeof(uint8_t), ndr->alloc_flags);


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static NTSTATUS
ndr_pull_echo_SinkData(struct ndr_pull *_ndr, int flags, struct echo_SinkData *r)
{
	struct ndr ndr;
	struct params_echo_SinkData params;

	memset(&params, 0, sizeof(params));
	ndr_init(&ndr,
			_ndr->data,
			_ndr->data_size,
			midlc_talloc_alloc,
			midlc_talloc_realloc,
			midlc_talloc_free,
			_ndr);

	if ((flags & NDR_OUT)) {
		dec_out_params_echo_SinkData(&ndr, &params, &ndr.deferred);
	}
	if ((flags & NDR_IN)) {
		dec_in_params_echo_SinkData(&ndr, &params, &ndr.deferred);
	}
    r->in.len = params.len;
    r->in.data = params.data;

	return NT_STATUS_OK;
}
static NTSTATUS
ndr_push_echo_SinkData(struct ndr_push *_ndr, int flags, struct echo_SinkData *r)
{
	struct ndr ndr;
	struct params_echo_SinkData params;

	memset(&params, 0, sizeof(params));
	ndr_init(&ndr,
			_ndr->data,
			_ndr->alloc_size,
			midlc_talloc_alloc,
			midlc_talloc_realloc,
			midlc_talloc_free,
			_ndr);

    params.len = r->in.len;
    params.data = r->in.data;

	if ((flags & NDR_OUT)) {
		enc_out_params_echo_SinkData(&ndr, &params, &ndr.deferred);
	}
	if ((flags & NDR_IN)) {
		enc_in_params_echo_SinkData(&ndr, &params, &ndr.deferred);
	}
	_ndr->data = ndr.data;
	_ndr->alloc_size = ndr.data_size;
	_ndr->offset = ndr.deferred;

	return NT_STATUS_OK;
}
void ndr_print_echo_SinkData(struct ndr_print *ndr, const char *name, int flags, struct echo_SinkData *r) { (void)ndr; (void)name; (void)flags; (void)r; };

static int
enc_in_params_echo_SourceData(struct ndr *ndr, struct params_echo_SourceData *obj, size_t *off)
{

    enc_ndr_long(ndr, obj->len, off);


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
dec_in_params_echo_SourceData(struct ndr *ndr, struct params_echo_SourceData *obj, size_t *off)
{
    uint32_t _datas;

    dec_ndr_long(ndr, &obj->len, off);

    _datas = obj->len;
    if (_datas > 0xFFFF) return -1;
    if (obj->data == NULL)
        obj->data = ndr->alloc(ndr->alloc_context, _datas * sizeof(uint8_t), ndr->alloc_flags);


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
enc_out_params_echo_SourceData(struct ndr *ndr, struct params_echo_SourceData *obj, size_t *off)
{
    uint32_t _datas;
    size_t _datao;
    uint32_t _i;

    _datas = obj->len;
    enc_ndr_long(ndr, _datas, off);
    _datao = *off;
    *off += 1 * _datas;
    off = &_datao;
    for (_i = 0; _i < _datas; _i++) {
        enc_ndr_small(ndr, obj->data[_i], off);
    }



    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
dec_out_params_echo_SourceData(struct ndr *ndr, struct params_echo_SourceData *obj, size_t *off)
{
    uint32_t _datas;
    size_t _datao;
    uint32_t _i;


    _datas = obj->len;
    dec_ndr_long(ndr, &_datas, off);
    _datao = *off;
    *off += 1 * _datas;
    if (_datas > 0xFFFF) return -1;
    if (obj->data == NULL)
        obj->data = ndr->alloc(ndr->alloc_context, _datas * sizeof(uint8_t), ndr->alloc_flags);
    off = &_datao;
    for (_i = 0; _i < _datas; _i++) {
        dec_ndr_small(ndr, obj->data + _i, off);
    }


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static NTSTATUS
ndr_pull_echo_SourceData(struct ndr_pull *_ndr, int flags, struct echo_SourceData *r)
{
	struct ndr ndr;
	struct params_echo_SourceData params;

	memset(&params, 0, sizeof(params));
	ndr_init(&ndr,
			_ndr->data,
			_ndr->data_size,
			midlc_talloc_alloc,
			midlc_talloc_realloc,
			midlc_talloc_free,
			_ndr);

	if ((flags & NDR_OUT)) {
		dec_out_params_echo_SourceData(&ndr, &params, &ndr.deferred);
	}
	if ((flags & NDR_IN)) {
		dec_in_params_echo_SourceData(&ndr, &params, &ndr.deferred);
	}
    r->in.len = params.len;
    r->out.data = params.data;

	return NT_STATUS_OK;
}
static NTSTATUS
ndr_push_echo_SourceData(struct ndr_push *_ndr, int flags, struct echo_SourceData *r)
{
	struct ndr ndr;
	struct params_echo_SourceData params;

	memset(&params, 0, sizeof(params));
	ndr_init(&ndr,
			_ndr->data,
			_ndr->alloc_size,
			midlc_talloc_alloc,
			midlc_talloc_realloc,
			midlc_talloc_free,
			_ndr);

    params.len = r->in.len;
    params.data = r->out.data;

	if ((flags & NDR_OUT)) {
		enc_out_params_echo_SourceData(&ndr, &params, &ndr.deferred);
	}
	if ((flags & NDR_IN)) {
		enc_in_params_echo_SourceData(&ndr, &params, &ndr.deferred);
	}
	_ndr->data = ndr.data;
	_ndr->alloc_size = ndr.data_size;
	_ndr->offset = ndr.deferred;

	return NT_STATUS_OK;
}
void ndr_print_echo_SourceData(struct ndr_print *ndr, const char *name, int flags, struct echo_SourceData *r) { (void)ndr; (void)name; (void)flags; (void)r; };

static int
enc_in_params_echo_TestCall(struct ndr *ndr, struct params_echo_TestCall *obj, size_t *off)
{

    enc_ndr_referent(ndr, obj->s1, 1, off);
    if (obj->s1 != NULL) {

        enc_ndr_string(ndr, obj->s1, off);

    }


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
dec_in_params_echo_TestCall(struct ndr *ndr, struct params_echo_TestCall *obj, size_t *off)
{

    dec_ndr_long(ndr, (uint32_t *)&obj->s1, off);
    if (obj->s1 != NULL) {

        dec_ndr_string(ndr, &obj->s1, off);

    }



    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
enc_out_params_echo_TestCall(struct ndr *ndr, struct params_echo_TestCall *obj, size_t *off)
{

    enc_ndr_referent(ndr, obj->s2, 1, off);
    if (obj->s2 != NULL) {

        enc_ndr_string(ndr, obj->s2, off);

    }


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
dec_out_params_echo_TestCall(struct ndr *ndr, struct params_echo_TestCall *obj, size_t *off)
{


    dec_ndr_long(ndr, (uint32_t *)&obj->s2, off);
    if (obj->s2 != NULL) {

        dec_ndr_string(ndr, &obj->s2, off);

    }


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static NTSTATUS
ndr_pull_echo_TestCall(struct ndr_pull *_ndr, int flags, struct echo_TestCall *r)
{
	struct ndr ndr;
	struct params_echo_TestCall params;

	memset(&params, 0, sizeof(params));
	ndr_init(&ndr,
			_ndr->data,
			_ndr->data_size,
			midlc_talloc_alloc,
			midlc_talloc_realloc,
			midlc_talloc_free,
			_ndr);

	if ((flags & NDR_OUT)) {
		dec_out_params_echo_TestCall(&ndr, &params, &ndr.deferred);
	}
	if ((flags & NDR_IN)) {
		dec_in_params_echo_TestCall(&ndr, &params, &ndr.deferred);
	}
    r->in.s1 = params.s1;
    r->out.s2 = params.s2;

	return NT_STATUS_OK;
}
static NTSTATUS
ndr_push_echo_TestCall(struct ndr_push *_ndr, int flags, struct echo_TestCall *r)
{
	struct ndr ndr;
	struct params_echo_TestCall params;

	memset(&params, 0, sizeof(params));
	ndr_init(&ndr,
			_ndr->data,
			_ndr->alloc_size,
			midlc_talloc_alloc,
			midlc_talloc_realloc,
			midlc_talloc_free,
			_ndr);

    params.s1 = r->in.s1;
    params.s2 = r->out.s2;

	if ((flags & NDR_OUT)) {
		enc_out_params_echo_TestCall(&ndr, &params, &ndr.deferred);
	}
	if ((flags & NDR_IN)) {
		enc_in_params_echo_TestCall(&ndr, &params, &ndr.deferred);
	}
	_ndr->data = ndr.data;
	_ndr->alloc_size = ndr.data_size;
	_ndr->offset = ndr.deferred;

	return NT_STATUS_OK;
}
void ndr_print_echo_TestCall(struct ndr_print *ndr, const char *name, int flags, struct echo_TestCall *r) { (void)ndr; (void)name; (void)flags; (void)r; };

int
dec_echo_info1(struct ndr *ndr, echo_info1 *obj, size_t *off)
{

    dec_ndr_align(ndr, 1, off);

    dec_ndr_small(ndr, &obj->v, off);


    return 0;
}
int
enc_echo_info1(struct ndr *ndr, echo_info1 *obj, size_t *off)
{

    enc_ndr_align(ndr, 1, off);
    enc_ndr_small(ndr, obj->v, off);


    return 0;
}
int
dec_echo_info2(struct ndr *ndr, echo_info2 *obj, size_t *off)
{

    dec_ndr_align(ndr, 2, off);

    dec_ndr_short(ndr, &obj->v, off);


    return 0;
}
int
enc_echo_info2(struct ndr *ndr, echo_info2 *obj, size_t *off)
{

    enc_ndr_align(ndr, 2, off);
    enc_ndr_short(ndr, obj->v, off);


    return 0;
}
int
dec_echo_info3(struct ndr *ndr, echo_info3 *obj, size_t *off)
{

    dec_ndr_align(ndr, 4, off);

    dec_ndr_long(ndr, &obj->v, off);


    return 0;
}
int
enc_echo_info3(struct ndr *ndr, echo_info3 *obj, size_t *off)
{

    enc_ndr_align(ndr, 4, off);
    enc_ndr_long(ndr, obj->v, off);


    return 0;
}
int
dec_echo_info4(struct ndr *ndr, echo_info4 *obj, size_t *off)
{

    dec_ndr_align(ndr, 8, off);

    dec_ndr_hyper(ndr, &obj->v, off);


    return 0;
}
int
enc_echo_info4(struct ndr *ndr, echo_info4 *obj, size_t *off)
{

    enc_ndr_align(ndr, 8, off);
    enc_ndr_hyper(ndr, obj->v, off);


    return 0;
}
int
dec_echo_info5(struct ndr *ndr, echo_info5 *obj, size_t *off)
{

    dec_ndr_align(ndr, 8, off);

    dec_ndr_small(ndr, &obj->v1, off);
    dec_ndr_hyper(ndr, &obj->v2, off);


    return 0;
}
int
enc_echo_info5(struct ndr *ndr, echo_info5 *obj, size_t *off)
{

    enc_ndr_align(ndr, 8, off);
    enc_ndr_small(ndr, obj->v1, off);
    enc_ndr_hyper(ndr, obj->v2, off);


    return 0;
}
int
dec_echo_info6(struct ndr *ndr, echo_info6 *obj, size_t *off)
{

    dec_ndr_align(ndr, 1, off);

    dec_ndr_small(ndr, &obj->v1, off);
    dec_ndr_small(ndr, &obj->info1.v, off);


    return 0;
}
int
enc_echo_info6(struct ndr *ndr, echo_info6 *obj, size_t *off)
{

    enc_ndr_align(ndr, 1, off);
    enc_ndr_small(ndr, obj->v1, off);
    enc_ndr_small(ndr, obj->info1.v, off);


    return 0;
}
int
dec_echo_info7(struct ndr *ndr, echo_info7 *obj, size_t *off)
{

    dec_ndr_align(ndr, 8, off);

    dec_ndr_small(ndr, &obj->v1, off);
    dec_ndr_hyper(ndr, &obj->info4.v, off);


    return 0;
}
int
enc_echo_info7(struct ndr *ndr, echo_info7 *obj, size_t *off)
{

    enc_ndr_align(ndr, 8, off);
    enc_ndr_small(ndr, obj->v1, off);
    enc_ndr_hyper(ndr, obj->info4.v, off);


    return 0;
}
static int
enc_in_params_echo_TestCall2(struct ndr *ndr, struct params_echo_TestCall2 *obj, size_t *off)
{

    enc_ndr_short(ndr, obj->level, off);


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
dec_in_params_echo_TestCall2(struct ndr *ndr, struct params_echo_TestCall2 *obj, size_t *off)
{

    dec_ndr_short(ndr, &obj->level, off);

    if (obj->info == NULL)
        obj->info = ndr->alloc(ndr->alloc_context, sizeof(echo_Info), ndr->alloc_flags);


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
enc_out_params_echo_TestCall2(struct ndr *ndr, struct params_echo_TestCall2 *obj, size_t *off)
{

    enc_ndr_referent(ndr, obj->info, 1, off);
    if (obj->info != NULL) {
        uint16_t _descr;

        _descr = obj->level;
        enc_ndr_short(ndr, _descr, off);
        switch (_descr) {
            case 1:
                enc_echo_info1(ndr, (echo_info1 *)obj->info, off);
                break;
            case 2:
                enc_echo_info2(ndr, (echo_info2 *)obj->info, off);
                break;
            case 3:
                enc_echo_info3(ndr, (echo_info3 *)obj->info, off);
                break;
            case 4:
                enc_echo_info4(ndr, (echo_info4 *)obj->info, off);
                break;
            case 5:
                enc_echo_info5(ndr, (echo_info5 *)obj->info, off);
                break;
            case 6:
                enc_echo_info6(ndr, (echo_info6 *)obj->info, off);
                break;
            case 7:
                enc_echo_info7(ndr, (echo_info7 *)obj->info, off);
                break;
        }

    }

    enc_ndr_long(ndr, obj->retval.v, off);

    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
dec_out_params_echo_TestCall2(struct ndr *ndr, struct params_echo_TestCall2 *obj, size_t *off)
{


    if (obj->info == NULL)
        obj->info = ndr->alloc(ndr->alloc_context, sizeof(echo_Info), ndr->alloc_flags);
    dec_ndr_long(ndr, (uint32_t *)&obj->info, off);
    if (obj->info != NULL) {
        uint16_t _descr;

        dec_ndr_short(ndr, &_descr, off);
        switch (_descr) {
            case 1:
                dec_echo_info1(ndr, (echo_info1 *)&obj->info, off);
                break;
            case 2:
                dec_echo_info2(ndr, (echo_info2 *)&obj->info, off);
                break;
            case 3:
                dec_echo_info3(ndr, (echo_info3 *)&obj->info, off);
                break;
            case 4:
                dec_echo_info4(ndr, (echo_info4 *)&obj->info, off);
                break;
            case 5:
                dec_echo_info5(ndr, (echo_info5 *)&obj->info, off);
                break;
            case 6:
                dec_echo_info6(ndr, (echo_info6 *)&obj->info, off);
                break;
            case 7:
                dec_echo_info7(ndr, (echo_info7 *)&obj->info, off);
                break;
        }

    }


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static NTSTATUS
ndr_pull_echo_TestCall2(struct ndr_pull *_ndr, int flags, struct echo_TestCall2 *r)
{
	struct ndr ndr;
	struct params_echo_TestCall2 params;

	memset(&params, 0, sizeof(params));
	ndr_init(&ndr,
			_ndr->data,
			_ndr->data_size,
			midlc_talloc_alloc,
			midlc_talloc_realloc,
			midlc_talloc_free,
			_ndr);

	if ((flags & NDR_OUT)) {
		dec_out_params_echo_TestCall2(&ndr, &params, &ndr.deferred);
	}
	if ((flags & NDR_IN)) {
		dec_in_params_echo_TestCall2(&ndr, &params, &ndr.deferred);
	}
    r->in.level = params.level;
    r->out.info = params.info;

	return NT_STATUS_OK;
}
static NTSTATUS
ndr_push_echo_TestCall2(struct ndr_push *_ndr, int flags, struct echo_TestCall2 *r)
{
	struct ndr ndr;
	struct params_echo_TestCall2 params;

	memset(&params, 0, sizeof(params));
	ndr_init(&ndr,
			_ndr->data,
			_ndr->alloc_size,
			midlc_talloc_alloc,
			midlc_talloc_realloc,
			midlc_talloc_free,
			_ndr);

    params.level = r->in.level;
    params.info = r->out.info;
    params.retval = r->out.result;

	if ((flags & NDR_OUT)) {
		enc_out_params_echo_TestCall2(&ndr, &params, &ndr.deferred);
	}
	if ((flags & NDR_IN)) {
		enc_in_params_echo_TestCall2(&ndr, &params, &ndr.deferred);
	}
	_ndr->data = ndr.data;
	_ndr->alloc_size = ndr.data_size;
	_ndr->offset = ndr.deferred;

	return NT_STATUS_OK;
}
void ndr_print_echo_TestCall2(struct ndr_print *ndr, const char *name, int flags, struct echo_TestCall2 *r) { (void)ndr; (void)name; (void)flags; (void)r; };

static int
enc_in_params_echo_TestSleep(struct ndr *ndr, struct params_echo_TestSleep *obj, size_t *off)
{

    enc_ndr_long(ndr, obj->seconds, off);


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
dec_in_params_echo_TestSleep(struct ndr *ndr, struct params_echo_TestSleep *obj, size_t *off)
{

    dec_ndr_long(ndr, &obj->seconds, off);


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
enc_out_params_echo_TestSleep(struct ndr *ndr, struct params_echo_TestSleep *obj, size_t *off)
{

    enc_ndr_long(ndr, obj->retval, off);

    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
dec_out_params_echo_TestSleep(struct ndr *ndr, struct params_echo_TestSleep *obj, size_t *off)
{



    (void)ndr; (void)obj; (void)off;
    return 0;
}
static NTSTATUS
ndr_pull_echo_TestSleep(struct ndr_pull *_ndr, int flags, struct echo_TestSleep *r)
{
	struct ndr ndr;
	struct params_echo_TestSleep params;

	memset(&params, 0, sizeof(params));
	ndr_init(&ndr,
			_ndr->data,
			_ndr->data_size,
			midlc_talloc_alloc,
			midlc_talloc_realloc,
			midlc_talloc_free,
			_ndr);

	if ((flags & NDR_OUT)) {
		dec_out_params_echo_TestSleep(&ndr, &params, &ndr.deferred);
	}
	if ((flags & NDR_IN)) {
		dec_in_params_echo_TestSleep(&ndr, &params, &ndr.deferred);
	}
    r->in.seconds = params.seconds;

	return NT_STATUS_OK;
}
static NTSTATUS
ndr_push_echo_TestSleep(struct ndr_push *_ndr, int flags, struct echo_TestSleep *r)
{
	struct ndr ndr;
	struct params_echo_TestSleep params;

	memset(&params, 0, sizeof(params));
	ndr_init(&ndr,
			_ndr->data,
			_ndr->alloc_size,
			midlc_talloc_alloc,
			midlc_talloc_realloc,
			midlc_talloc_free,
			_ndr);

    params.seconds = r->in.seconds;
    params.retval = r->out.result;

	if ((flags & NDR_OUT)) {
		enc_out_params_echo_TestSleep(&ndr, &params, &ndr.deferred);
	}
	if ((flags & NDR_IN)) {
		enc_in_params_echo_TestSleep(&ndr, &params, &ndr.deferred);
	}
	_ndr->data = ndr.data;
	_ndr->alloc_size = ndr.data_size;
	_ndr->offset = ndr.deferred;

	return NT_STATUS_OK;
}
void ndr_print_echo_TestSleep(struct ndr_print *ndr, const char *name, int flags, struct echo_TestSleep *r) { (void)ndr; (void)name; (void)flags; (void)r; };

int
dec_echo_Enum2(struct ndr *ndr, echo_Enum2 *obj, size_t *off)
{

    dec_ndr_align(ndr, 4, off);

    dec_ndr_short(ndr, &obj->e1, off);
    dec_ndr_long(ndr, &obj->e2, off);


    return 0;
}
int
enc_echo_Enum2(struct ndr *ndr, echo_Enum2 *obj, size_t *off)
{

    enc_ndr_align(ndr, 4, off);
    enc_ndr_short(ndr, obj->e1, off);
    enc_ndr_long(ndr, obj->e2, off);


    return 0;
}
static int
enc_in_params_echo_TestEnum(struct ndr *ndr, struct params_echo_TestEnum *obj, size_t *off)
{
    int _descr;

    enc_ndr_short(ndr, *obj->foo1, off);

    enc_echo_Enum2(ndr, obj->foo2, off);

    _descr = *obj->foo1;
    enc_ndr_short(ndr, _descr, off);
    switch (_descr) {
        case ECHO_ENUM1:
            enc_ndr_short(ndr, *(echo_Enum1 *)obj->foo3, off);
            break;
        case ECHO_ENUM2:
            enc_echo_Enum2(ndr, (echo_Enum2 *)obj->foo3, off);
            break;
    }


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
dec_in_params_echo_TestEnum(struct ndr *ndr, struct params_echo_TestEnum *obj, size_t *off)
{
    int _descr;

    if (obj->foo1 == NULL)
        obj->foo1 = ndr->alloc(ndr->alloc_context, sizeof(int), ndr->alloc_flags);
    dec_ndr_short(ndr, obj->foo1, off);

    if (obj->foo2 == NULL)
        obj->foo2 = ndr->alloc(ndr->alloc_context, sizeof(echo_Enum2), ndr->alloc_flags);
    dec_echo_Enum2(ndr, obj->foo2, off);

    if (obj->foo3 == NULL)
        obj->foo3 = ndr->alloc(ndr->alloc_context, sizeof(echo_Enum3), ndr->alloc_flags);
    dec_ndr_short(ndr, &_descr, off);
    switch (_descr) {
        case ECHO_ENUM1:
            dec_ndr_short(ndr, obj->foo3, off);
            break;
        case ECHO_ENUM2:
            dec_echo_Enum2(ndr, (echo_Enum2 *)&obj->foo3, off);
            break;
    }


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
enc_out_params_echo_TestEnum(struct ndr *ndr, struct params_echo_TestEnum *obj, size_t *off)
{
    int _descr;

    enc_ndr_short(ndr, *obj->foo1, off);

    enc_echo_Enum2(ndr, obj->foo2, off);

    _descr = *obj->foo1;
    enc_ndr_short(ndr, _descr, off);
    switch (_descr) {
        case ECHO_ENUM1:
            enc_ndr_short(ndr, *(echo_Enum1 *)obj->foo3, off);
            break;
        case ECHO_ENUM2:
            enc_echo_Enum2(ndr, (echo_Enum2 *)obj->foo3, off);
            break;
    }


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static int
dec_out_params_echo_TestEnum(struct ndr *ndr, struct params_echo_TestEnum *obj, size_t *off)
{
    int _descr;

    if (obj->foo1 == NULL)
        obj->foo1 = ndr->alloc(ndr->alloc_context, sizeof(int), ndr->alloc_flags);
    dec_ndr_short(ndr, obj->foo1, off);

    if (obj->foo2 == NULL)
        obj->foo2 = ndr->alloc(ndr->alloc_context, sizeof(echo_Enum2), ndr->alloc_flags);
    dec_echo_Enum2(ndr, obj->foo2, off);

    if (obj->foo3 == NULL)
        obj->foo3 = ndr->alloc(ndr->alloc_context, sizeof(echo_Enum3), ndr->alloc_flags);
    dec_ndr_short(ndr, &_descr, off);
    switch (_descr) {
        case ECHO_ENUM1:
            dec_ndr_short(ndr, obj->foo3, off);
            break;
        case ECHO_ENUM2:
            dec_echo_Enum2(ndr, (echo_Enum2 *)&obj->foo3, off);
            break;
    }


    (void)ndr; (void)obj; (void)off;
    return 0;
}
static NTSTATUS
ndr_pull_echo_TestEnum(struct ndr_pull *_ndr, int flags, struct echo_TestEnum *r)
{
	struct ndr ndr;
	struct params_echo_TestEnum params;

	memset(&params, 0, sizeof(params));
	ndr_init(&ndr,
			_ndr->data,
			_ndr->data_size,
			midlc_talloc_alloc,
			midlc_talloc_realloc,
			midlc_talloc_free,
			_ndr);

	if ((flags & NDR_OUT)) {
		dec_out_params_echo_TestEnum(&ndr, &params, &ndr.deferred);
	}
	if ((flags & NDR_IN)) {
		dec_in_params_echo_TestEnum(&ndr, &params, &ndr.deferred);
	}
    r->in.foo1 = params.foo1;
    r->out.foo1 = params.foo1;
    r->in.foo2 = params.foo2;
    r->out.foo2 = params.foo2;
    r->in.foo3 = params.foo3;
    r->out.foo3 = params.foo3;

	return NT_STATUS_OK;
}
static NTSTATUS
ndr_push_echo_TestEnum(struct ndr_push *_ndr, int flags, struct echo_TestEnum *r)
{
	struct ndr ndr;
	struct params_echo_TestEnum params;

	memset(&params, 0, sizeof(params));
	ndr_init(&ndr,
			_ndr->data,
			_ndr->alloc_size,
			midlc_talloc_alloc,
			midlc_talloc_realloc,
			midlc_talloc_free,
			_ndr);

    params.foo1 = r->in.foo1;
    params.foo1 = r->out.foo1;
    params.foo2 = r->in.foo2;
    params.foo2 = r->out.foo2;
    params.foo3 = r->in.foo3;
    params.foo3 = r->out.foo3;

	if ((flags & NDR_OUT)) {
		enc_out_params_echo_TestEnum(&ndr, &params, &ndr.deferred);
	}
	if ((flags & NDR_IN)) {
		enc_in_params_echo_TestEnum(&ndr, &params, &ndr.deferred);
	}
	_ndr->data = ndr.data;
	_ndr->alloc_size = ndr.data_size;
	_ndr->offset = ndr.deferred;

	return NT_STATUS_OK;
}
void ndr_print_echo_TestEnum(struct ndr_print *ndr, const char *name, int flags, struct echo_TestEnum *r) { (void)ndr; (void)name; (void)flags; (void)r; };

static const struct dcerpc_interface_call rpcecho_calls[] = {
    {
        "echo_AddOne",
        sizeof(struct echo_AddOne),
        (ndr_push_flags_fn_t)ndr_push_echo_AddOne,
        (ndr_pull_flags_fn_t)ndr_pull_echo_AddOne,
        (ndr_print_function_t)ndr_print_echo_AddOne,
    },
    {
        "echo_EchoData",
        sizeof(struct echo_EchoData),
        (ndr_push_flags_fn_t)ndr_push_echo_EchoData,
        (ndr_pull_flags_fn_t)ndr_pull_echo_EchoData,
        (ndr_print_function_t)ndr_print_echo_EchoData,
    },
    {
        "echo_SinkData",
        sizeof(struct echo_SinkData),
        (ndr_push_flags_fn_t)ndr_push_echo_SinkData,
        (ndr_pull_flags_fn_t)ndr_pull_echo_SinkData,
        (ndr_print_function_t)ndr_print_echo_SinkData,
    },
    {
        "echo_SourceData",
        sizeof(struct echo_SourceData),
        (ndr_push_flags_fn_t)ndr_push_echo_SourceData,
        (ndr_pull_flags_fn_t)ndr_pull_echo_SourceData,
        (ndr_print_function_t)ndr_print_echo_SourceData,
    },
    {
        "echo_TestCall",
        sizeof(struct echo_TestCall),
        (ndr_push_flags_fn_t)ndr_push_echo_TestCall,
        (ndr_pull_flags_fn_t)ndr_pull_echo_TestCall,
        (ndr_print_function_t)ndr_print_echo_TestCall,
    },
    {
        "echo_TestCall2",
        sizeof(struct echo_TestCall2),
        (ndr_push_flags_fn_t)ndr_push_echo_TestCall2,
        (ndr_pull_flags_fn_t)ndr_pull_echo_TestCall2,
        (ndr_print_function_t)ndr_print_echo_TestCall2,
    },
    {
        "echo_TestSleep",
        sizeof(struct echo_TestSleep),
        (ndr_push_flags_fn_t)ndr_push_echo_TestSleep,
        (ndr_pull_flags_fn_t)ndr_pull_echo_TestSleep,
        (ndr_print_function_t)ndr_print_echo_TestSleep,
    },
    {
        "echo_TestEnum",
        sizeof(struct echo_TestEnum),
        (ndr_push_flags_fn_t)ndr_push_echo_TestEnum,
        (ndr_pull_flags_fn_t)ndr_pull_echo_TestEnum,
        (ndr_print_function_t)ndr_print_echo_TestEnum,
    },
	{ NULL, 0, NULL, NULL, NULL }
};

static const char * const rpcecho_endpoint_strings[] = {
    "ncacn_np:[\\pipe\\rpcecho]",
    "ncacn_ip_tcp:",
    "ncalrpc:"
};

static const struct dcerpc_endpoint_list rpcecho_endpoints = {
    3, rpcecho_endpoint_strings
};

const struct dcerpc_interface_table dcerpc_table_rpcecho = {
	"rpcecho",
	DCERPC_RPCECHO_UUID,
	DCERPC_RPCECHO_VERSION,
	DCERPC_RPCECHO_HELPSTRING,
	8,
	rpcecho_calls,
	&rpcecho_endpoints
};

static NTSTATUS dcerpc_ndr_rpcecho_init(void)
{
	return librpc_register_interface(&dcerpc_table_rpcecho);
}

NTSTATUS dcerpc_echo_init(void)
{
	NTSTATUS status = NT_STATUS_OK;
	status = dcerpc_ndr_rpcecho_init();
	if (NT_STATUS_IS_ERR(status)) {
		return status;
	}

	return status;
}

