#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

#include <mba/csv.h>
#include <mba/msgno.h>

#include "sym.h"
#include "midlc.h"

int
emit_op_frag(struct idl *idl, struct sym *sym, int indent, int push)
{
	const char *enc = push ? "enc" : "dec";
	iter_t iter;
	struct sym *mem;

	print(idl, indent, "static NTSTATUS\nndr_%s_%s(struct ndr_%s *_ndr, int flags, struct %s *r)", push ? "push" : "pull", sym->name, push ? "push" : "pull", sym->name);
	fprintf(idl->out, "\n"
	"{\n"
	"	struct ndr ndr;\n"
	"	struct params_%s params;\n"
	"\n"
	"	memset(&params, 0, sizeof(params));\n"
	"	ndr_init(&ndr,\n"
	"			_ndr->data,\n"
	"			_ndr->%s_size,\n"
	"			midlc_talloc_alloc,\n"
	"			midlc_talloc_realloc,\n"
	"			midlc_talloc_free,\n"
	"			_ndr);\n"
	"\n",
		sym->name,
		push ? "alloc" : "data");

	if (push) {
		linkedlist_iterate(&sym->mems, &iter);
		while ((mem = linkedlist_next(&sym->mems, &iter))) {
			if (hashmap_get(&mem->attrs, "in")) {
				print(idl, indent + 4, "params.%s = r->in.%s;\n", mem->name, mem->name);
			}
			if (hashmap_get(&mem->attrs, "out")) {
				print(idl, indent + 4, "params.%s = r->out.%s;\n", mem->name, mem->name);
			}
		}
		if (IS_OPERATION(sym) && strcmp(sym->idl_type, "void") != 0) {
			print(idl, indent + 4, "params.retval = r->out.result;\n");
		}
		fputc('\n', idl->out);
	}


	fprintf(idl->out,
	"	if ((flags & NDR_OUT)) {\n"
	"		%s_out_params_%s(&ndr, &params, &ndr.deferred);\n"
	"	}\n"
	"	if ((flags & NDR_IN)) {\n"
	"		%s_in_params_%s(&ndr, &params, &ndr.deferred);\n"
	"	}\n", enc, sym->name, enc, sym->name);

	if (!push) {
		linkedlist_iterate(&sym->mems, &iter);
		while ((mem = linkedlist_next(&sym->mems, &iter))) {
			if (hashmap_get(&mem->attrs, "in")) {
				print(idl, indent + 4, "r->in.%s = params.%s;\n", mem->name, mem->name);
			}
			if (hashmap_get(&mem->attrs, "out")) {
				print(idl, indent + 4, "r->out.%s = params.%s;\n", mem->name, mem->name);
			}
		}
	} else {
		fprintf(idl->out,
		"	_ndr->data = ndr.data;\n"
		"	_ndr->alloc_size = ndr.data_size;\n"
		"	_ndr->offset = ndr.deferred;\n");
	}

	fprintf(idl->out,
	"\n"
	"	return NT_STATUS_OK;\n"
	"}\n");

	return 0;
}
int
emit_op_print_frag(struct idl *idl, struct sym *sym, int indent)
{
	print(idl, indent, "void ndr_print_%s(struct ndr_print *ndr, const char *name, int flags, struct %s *r) { (void)ndr; (void)name; (void)flags; (void)r; };\n", sym->name, sym->name);
	return 0;
}
void
str_toupper(const char *str, char *dst)
{
	while (*str) {
		*dst++ = toupper(*str++);
	}
	*dst = '\0';
}
int
emit_typedefs(struct idl *idl, struct sym *sym)
{
	iter_t iter;
	struct sym *mem;

	print(idl, 0, "/* pidl doesn't emit typedef'd decls */\n");

	linkedlist_iterate(&sym->mems, &iter);
	while ((mem = linkedlist_next(&sym->mems, &iter))) {
		if (mem->noemit) {
			continue;
		}

		if (IS_TYPEDEFD(mem) && !IS_OPERATION(mem)) {
			if (strcmp(mem->idl_type, "NTSTATUS") == 0) {
				/* But NTSTATUS *is* typedef'd so skip it */
			} else if (IS_STRUCTURE(mem)) {
				print(idl, 0, "typedef struct %s %s;\n", mem->out_type, mem->out_type);
			} else if (IS_UNION(mem)) {
				print(idl, 0, "typedef union %s %s;\n", mem->out_type, mem->out_type);
			} else if (IS_ENUM(mem)) {
				print(idl, 0, "typedef enum %s %s;\n", mem->name, mem->name);
			}
		}
	}

	fputc('\n', idl->out);

	return 0;
}
int
emit_stub_samba(struct idl *idl, struct sym *iface)
{
	iter_t iter;
	struct sym *sym;
	char upper[255];
	char *endpoint;
	time_t now = time(NULL);
	int epcount, opcount;

	str_toupper(iface->name, upper);

	idl->opnum = 0;

	fprintf(idl->out, "/* Generated by MIDLC %s */\n"
	"#include \"includes.h\"\n"
	"#include \"librpc/gen_ndr/%s.h\"\n"
/* Really need to make midlc library for Samba but I don't want to mess with Samba
	"#include \"midlc/ndr.h\"\n"
*/
	"#include \"src/ndr.c\"\n"
	"\n"
	"static void *\n"
	"midlc_talloc_alloc(void *context, size_t size, int flags)\n"
	"{\n"
	"    (void)flags;\n"
	"    return talloc_size(context, size);\n"
	"}\n"
	"static void *\n"
	"midlc_talloc_realloc(void *context, void *ptr, size_t size)\n"
	"{\n"
	"    return talloc_realloc_size(context, ptr, size);\n"
	"}\n"
	"static int\n"
	"midlc_talloc_free(void *context, void *obj)\n"
	"{\n"
	"    (void)context;\n"
	"    return talloc_free(obj);\n"
	"}\n", ctime(&now), idl->outname);

	if (emit_imported_protos(idl, iface) == -1) {
		AMSG("");
		return -1;
	}

	emit_typedefs(idl, iface);

	linkedlist_iterate(&iface->mems, &iter);
	while ((sym = linkedlist_next(&iface->mems, &iter))) {
		if (sym->noemit) {
			continue;
		}
		if (IS_OPERATION(sym)) {
			struct sym sym0 = *sym;
			sym0.flags &= ~FLAGS_TYPEDEFD;
			emit_struct(idl, &sym0, 0);
			fputc('\n', idl->out);
		}
	}

	opcount = 0;
	linkedlist_iterate(&iface->mems, &iter);
	while ((sym = linkedlist_next(&iface->mems, &iter))) {
		if (sym->noemit) {
			continue;
		}

		if (IS_OPERATION(sym)) {
			opcount++;

			if (emit_params_encoder(idl, sym, 0, 0) == -1 ||
						emit_params_decoder(idl, sym, 0, 0) == -1 ||
						emit_params_encoder(idl, sym, 1, 0) == -1 ||
						emit_params_decoder(idl, sym, 1, 0) == -1) {
				AMSG("");
				return -1;
			}

			emit_op_frag(idl, sym, 0, 0);
			emit_op_frag(idl, sym, 0, 1);
			emit_op_print_frag(idl, sym, 0);

			fputc('\n', idl->out);
		} else if (!IS_PRIMATIVE(sym) && !IS_UNION(sym)) {
			if (emit_decoder(idl, sym, 0) == -1 ||
					emit_encoder(idl, sym, 0) == -1) {
				AMSG("");
				return -1;
			}
		}
	}

	print(idl, 0, "static const struct dcerpc_interface_call %s_calls[] = {\n", iface->name);

	linkedlist_iterate(&iface->mems, &iter);
	while ((sym = linkedlist_next(&iface->mems, &iter))) {
		if (sym->noemit) {
			continue;
		}

		if (IS_OPERATION(sym)) {
			print(idl, 4, "{\n");
			print(idl, 8, "\"%s\",\n", sym->name);
			print(idl, 8, "sizeof(struct %s),\n", sym->name);
			print(idl, 8, "(ndr_push_flags_fn_t)ndr_push_%s,\n", sym->name);
			print(idl, 8, "(ndr_pull_flags_fn_t)ndr_pull_%s,\n", sym->name);
			print(idl, 8, "(ndr_print_function_t)ndr_print_%s,\n", sym->name);
			print(idl, 4, "},\n");
		}
	}

	fputs("	{ NULL, 0, NULL, NULL, NULL }\n};\n\n", idl->out);

	if ((endpoint = hashmap_get(&iface->attrs, "endpoint"))) {
		unsigned char *eps[16], buf[4096];

		if (csv_row_parse(endpoint, strlen(endpoint) + 1,
				buf, 4096,
				eps, 16,
				',', CSV_TRIM | CSV_QUOTES) == -1) {
			AMSG("");
			return -1;
		}

		print(idl, 0, "static const char * const %s_endpoint_strings[] = {\n", iface->name);
		epcount = 0;
		while (eps[epcount]) {
			print(idl, 4, "\"%s\"", eps[epcount++]);
			if (eps[epcount]) {
				fputs(",\n", idl->out);
			}
		}
		print(idl, 0, "\n};\n");
	} else {
		PMSG("No endpoints specified for [interface]");
		return -1;
	}
	fputc('\n', idl->out);

	print(idl, 0, "static const struct dcerpc_endpoint_list %s_endpoints = {\n", iface->name);
	print(idl, 4, "%d, %s_endpoint_strings\n", epcount, iface->name);
	print(idl, 0, "};\n\n");

	print(idl, 0, "const struct dcerpc_interface_table dcerpc_table_%s = {\n"
		"	\"%s\",\n"
		"	DCERPC_%s_UUID,\n"
		"	DCERPC_%s_VERSION,\n"
		"	DCERPC_%s_HELPSTRING,\n"
		"	%d,\n"
		"	%s_calls,\n"
		"	&%s_endpoints\n"
		"};\n"
		"\n"
		"static NTSTATUS dcerpc_ndr_%s_init(void)\n"
		"{\n"
		"	return librpc_register_interface(&dcerpc_table_%s);\n"
		"}\n"
		"\n"
		"NTSTATUS dcerpc_%s_init(void)\n"
		"{\n"
		"	NTSTATUS status = NT_STATUS_OK;\n"
		"	status = dcerpc_ndr_%s_init();\n"
		"	if (NT_STATUS_IS_ERR(status)) {\n"
		"		return status;\n"
		"	}\n"
		"\n"
		"	return status;\n"
		"}\n\n",
			iface->name,
			iface->name,
			upper,
			upper,
			upper,
			opcount,
			iface->name,
			iface->name,
			iface->name,
			iface->name,
			idl->outname + 4, /* +4 to skip 'ndr_' */
			iface->name);

	return 0;
}

